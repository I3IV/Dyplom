{"ast":null,"code":"import _arity from './internal/_arity';\nimport _curry2 from './internal/_curry2';\nimport _has from './internal/_has';\n/**\r\n * A customisable version of [`R.memoize`](#memoize). `memoizeWith` takes an\r\n * additional function that will be applied to a given argument set and used to\r\n * create the cache key under which the results of the function to be memoized\r\n * will be stored. Care must be taken when implementing key generation to avoid\r\n * clashes that may overwrite previous entries erroneously.\r\n *\r\n *\r\n * @func\r\n * @memberOf R\r\n * @since v0.24.0\r\n * @category Function\r\n * @sig (*... -> String) -> (*... -> a) -> (*... -> a)\r\n * @param {Function} fn The function to generate the cache key.\r\n * @param {Function} fn The function to memoize.\r\n * @return {Function} Memoized version of `fn`.\r\n * @see R.memoize\r\n * @example\r\n *\r\n *      let count = 0;\r\n *      const factorial = R.memoizeWith(R.identity, n => {\r\n *        count += 1;\r\n *        return R.product(R.range(1, n + 1));\r\n *      });\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      factorial(5); //=> 120\r\n *      count; //=> 1\r\n */\n\nvar memoizeWith =\n/*#__PURE__*/\n_curry2(function memoizeWith(mFn, fn) {\n  var cache = {};\n  return _arity(fn.length, function () {\n    var key = mFn.apply(this, arguments);\n\n    if (!_has(key, cache)) {\n      cache[key] = fn.apply(this, arguments);\n    }\n\n    return cache[key];\n  });\n});\n\nexport default memoizeWith;","map":null,"metadata":{},"sourceType":"module"}